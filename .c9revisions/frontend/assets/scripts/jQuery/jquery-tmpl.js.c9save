{"ts":1362250335258,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1362250339599,"patch":[[{"diffs":[[1,"/*!\r\n * $ Templates Plugin 1.1\r\n * https://github.com/KanbanSolutions/jquery-tmpl\r\n * Requires $ 1.4.2\r\n *\r\n * Copyright Software Freedom Conservancy, Inc.\r\n * Dual licensed under the MIT or GPL Version 2 licenses.\r\n * http://jquery.org/license\r\n */\r\n\r\n/*\r\n    Tags:\r\n    {%if <condition> %}<action>{%/if%}\r\n    {%if <condition> %}<action>{%else%}<action>{%/if%}\r\n    {%if <condition> %}<action>{%elif <condition> %}<action>{%else%}<action>{%/if%}\r\n    {%each <array_or_object> %}$value, $index{%/each%}\r\n    {%tmpl <template>%}\r\n    {%= js call %}\r\n    {%html js call %}\r\n*/\r\n(function($, undefined) {\r\n    var oldManip = $.fn.domManip, tmplItmAtt = \"_tmplitem\",\r\n            newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];\r\n\r\n\r\n    var regex = {\r\n        sq_escape: /([\\\\'])/g,\r\n        sq_unescape: /\\\\'/g,\r\n        dq_unescape: /\\\\\\\\/g,\r\n        nl_strip: /[\\r\\t\\n]/g,\r\n        shortcut_replace: /\\$\\{([^\\}]*)\\}/g,\r\n        lang_parse: /\\{\\%(\\/?)(\\w+|.)(?:\\(((?:[^\\%]|\\%(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\%]|\\%(?!\\}))*?)\\))?\\s*\\%\\}/g,\r\n        old_lang_parse: /\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,\r\n        template_anotate: /(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g,\r\n        text_only_template: /^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/,\r\n        html_expr: /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! |\\{\\%! /,\r\n        last_word: /\\w$/\r\n    };\r\n\r\n    function newTmplItem(options, parentItem, fn, data) {\r\n        // Returns a template item data structure for a new rendered instance of a template (a 'template item').\r\n        // The content field is a hierarchical array of strings and nested items (to be\r\n        // removed and replaced by nodes field of dom elements, once inserted in DOM).\r\n        var newItem = {\r\n            data: data || (data === 0 || data === false) ? data : (parentItem ? parentItem.data : {}),\r\n            _wrap: parentItem ? parentItem._wrap : null,\r\n            tmpl: null,\r\n            parent: parentItem || null,\r\n            nodes: [],\r\n            calls: tiCalls,\r\n            nest: tiNest,\r\n            wrap: tiWrap,\r\n            html: tiHtml,\r\n            update: tiUpdate\r\n        };\r\n        if(options) {\r\n            $.extend(newItem, options, { nodes: [], parent: parentItem });\r\n        }\r\n        if(fn) {\r\n            // Build the hierarchical content to be used during insertion into DOM\r\n            newItem.tmpl = fn;\r\n            newItem._ctnt = newItem._ctnt || $.isFunction(newItem.tmpl) && newItem.tmpl($, newItem) || fn;\r\n            newItem.key = ++itemKey;\r\n            // Keep track of new template item, until it is stored as $ Data on DOM element\r\n            (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\r\n        }\r\n        return newItem;\r\n    }\r\n\r\n    // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\r\n    $.each({\r\n                appendTo: \"append\",\r\n                prependTo: \"prepend\",\r\n                insertBefore: \"before\",\r\n                insertAfter: \"after\",\r\n                replaceAll: \"replaceWith\"\r\n            }, function(name, original) {\r\n                $.fn[ name ] = function(selector) {\r\n                    var ret = [], insert = $(selector), elems, i, l, tmplItems,\r\n                            parent = this.length === 1 && this[0].parentNode;\r\n\r\n                    appendToTmplItems = newTmplItems || {};\r\n                    if(parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {\r\n                        insert[ original ](this[0]);\r\n                        ret = this;\r\n                    } else {\r\n                        for(i = 0,l = insert.length; i < l; i++) {\r\n                            cloneIndex = i;\r\n                            elems = (i > 0 ? this.clone(true) : this).get();\r\n                            $(insert[i])[ original ](elems);\r\n                            ret = ret.concat(elems);\r\n                        }\r\n                        cloneIndex = 0;\r\n                        ret = this.pushStack(ret, name, insert.selector);\r\n                    }\r\n                    tmplItems = appendToTmplItems;\r\n                    appendToTmplItems = null;\r\n                    $.tmpl.complete(tmplItems);\r\n                    return ret;\r\n                };\r\n            });\r\n\r\n    $.fn.extend({\r\n        // Use first wrapped element as template markup.\r\n        // Return wrapped set of template items, obtained by rendering template against data.\r\n        tmpl: function(data, options, parentItem) {\r\n            var ret = $.tmpl(this[0], data, options, parentItem);\r\n            return ret;\r\n        },\r\n\r\n        // Find which rendered template item the first wrapped DOM element belongs to\r\n        tmplItem: function() {\r\n            var ret = $.tmplItem(this[0]);\r\n            return ret;\r\n        },\r\n\r\n        // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\r\n        template: function(name) {\r\n            var ret = $.template(name, this[0]);\r\n            return ret;\r\n        },\r\n\r\n        domManip: function(args, table, callback, options) {\r\n            if(args[0] && $.isArray(args[0])) {\r\n                var dmArgs = $.makeArray(arguments), elems = args[0], elemsLength = elems.length, i = 0, tmplItem;\r\n                while(i < elemsLength && !(tmplItem = $.data(elems[i++], \"tmplItem\"))) {\r\n                }\r\n                if(tmplItem && cloneIndex) {\r\n                    dmArgs[2] = function(fragClone) {\r\n                        // Handler called by oldManip when rendered template has been inserted into DOM.\r\n                        $.tmpl.afterManip(this, fragClone, callback);\r\n                    };\r\n                }\r\n                oldManip.apply(this, dmArgs);\r\n            } else {\r\n                oldManip.apply(this, arguments);\r\n            }\r\n            cloneIndex = 0;\r\n            if(!appendToTmplItems) {\r\n                $.tmpl.complete(newTmplItems);\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n\r\n    $.extend({\r\n        // Return wrapped set of template items, obtained by rendering template against data.\r\n        tmpl: function(tmpl, data, options, parentItem) {\r\n            var ret, topLevel = !parentItem;\r\n            if(topLevel) {\r\n                // This is a top-level tmpl call (not from a nested template using {{tmpl}})\r\n                parentItem = topTmplItem;\r\n                tmpl = $.template[tmpl] || $.template(null, tmpl);\r\n                wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\r\n            } else if(!tmpl) {\r\n                // The template item is already associated with DOM - this is a refresh.\r\n                // Re-evaluate rendered template for the parentItem\r\n                tmpl = parentItem.tmpl;\r\n                newTmplItems[parentItem.key] = parentItem;\r\n                parentItem.nodes = [];\r\n                if(parentItem.wrapped) {\r\n                    updateWrapped(parentItem, parentItem.wrapped);\r\n                }\r\n                // Rebuild, without creating a new template item\r\n                return $(build(parentItem, null, parentItem.tmpl($, parentItem)));\r\n            }\r\n            if(!tmpl) {\r\n                return []; // Could throw...\r\n            }\r\n            if(typeof data === \"function\") {\r\n                data = data.call(parentItem || {});\r\n            }\r\n            if(options && options.wrapped) {\r\n                updateWrapped(options, options.wrapped);\r\n            }\r\n            ret = $.isArray(data) ?\r\n                    $.map(data, function(dataItem) {\r\n                        return dataItem ? newTmplItem(options, parentItem, tmpl, dataItem) : null;\r\n                    }) :\r\n                    [ newTmplItem(options, parentItem, tmpl, data) ];\r\n            return topLevel ? $(build(parentItem, null, ret)) : ret;\r\n        },\r\n\r\n        // Return rendered template item for an element.\r\n        tmplItem: function(elem) {\r\n            var tmplItem;\r\n            if(elem instanceof $) {\r\n                elem = elem[0];\r\n            }\r\n            while(elem && elem.nodeType === 1 && !(tmplItem = $.data(elem,\r\n                    \"tmplItem\")) && (elem = elem.parentNode)) {\r\n            }\r\n            return tmplItem || topTmplItem;\r\n        },\r\n\r\n        // Set:\r\n        // Use $.template( name, tmpl ) to cache a named template,\r\n        // where tmpl is a template string, a script element or a $ instance wrapping a script element, etc.\r\n        // Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\r\n\r\n        // Get:\r\n        // Use $.template( name ) to access a cached template.\r\n        // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\r\n        // will return the compiled template, without adding a name reference.\r\n        // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\r\n        // to $.template( null, templateString )\r\n        template: function(name, tmpl) {\r\n            if(tmpl) {\r\n                // Compile template and associate with name\r\n                if(typeof tmpl === \"string\") {\r\n                    // This is an HTML string being passed directly in.\r\n                    tmpl = buildTmplFn(tmpl)\r\n                } else if(tmpl instanceof $) {\r\n                    tmpl = tmpl[0] || {};\r\n                }\r\n                if(tmpl.nodeType) {\r\n                    // If this is a template block, use cached copy, or generate tmpl function and cache.\r\n                    tmpl = $.data(tmpl, \"tmpl\") || $.data(tmpl, \"tmpl\", buildTmplFn(tmpl.innerHTML));\r\n                    // Issue: In IE, if the container element is not a script block, the innerHTML will remove quotes from attribute values whenever the value does not include white space.\r\n                    // This means that foo=\"${x}\" will not work if the value of x includes white space: foo=\"${x}\" -> foo=value of x.\r\n                    // To correct this, include space in tag: foo=\"${ x }\" -> foo=\"value of x\"\r\n                }\r\n                return typeof name === \"string\" ? ($.template[name] = tmpl) : tmpl;\r\n            }\r\n            // Return named compiled template\r\n            return name ? (typeof name !== \"string\" ? $.template(null, name) :\r\n                    ($.template[name] ||\r\n                        // If not in map, treat as a selector. (If integrated with core, use quickExpr.exec)\r\n                     $.template(null, name))) : null;\r\n        },\r\n\r\n        encode: function(text) {\r\n            // Do HTML encoding replacing < > & and ' and \" by corresponding entities.\r\n            return (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\r\n        }\r\n    });\r\n\r\n    $.extend($.tmpl, {\r\n        tag: {\r\n            \"tmpl\": {\r\n                _default: { $2: \"null\" },\r\n                open: \"if($notnull_1){__=__.concat($item.nest($1,$2));}\"\r\n                // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\r\n                // This means that {{tmpl foo}} treats foo as a template (which IS a function).\r\n                // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\r\n            },\r\n            \"wrap\": {\r\n                _default: { $2: \"null\" },\r\n                open: \"$item.calls(__,$1,$2);__=[];\",\r\n                close: \"call=$item.calls();__=call._.concat($item.wrap(call,__));\"\r\n            },\r\n            \"each\": {\r\n                _default: { $2: \"$index, $value\" },\r\n                open: \"if($notnull_1){$.each($1a,function($2){with(this){\",\r\n                close: \"}});}\"\r\n            },\r\n            \"if\": {\r\n                open: \"if(($notnull_1) && $1a){\",\r\n                close: \"}\"\r\n            },\r\n            \"else\": {\r\n                open: \"}else{\"\r\n            },\r\n            \"elif\": {\r\n                open: \"}else if(($notnull_1) && $1a){\"\r\n            },\r\n            \"elseif\": {\r\n                open: \"}else if(($notnull_1) && $1a){\"\r\n            },\r\n            \"html\": {\r\n                // Unecoded expression evaluation.\r\n                open: \"if($notnull_1){__.push($1a);}\"\r\n            },\r\n            \"=\": {\r\n                // Encoded expression evaluation. Abbreviated form is ${}.\r\n                _default: { $1: \"$data\" },\r\n                open: \"if($notnull_1){__.push($.encode($1a));}\"\r\n            },\r\n            \"!\": {\r\n                // Comment tag. Skipped by parser\r\n                open: \"\"\r\n            }\r\n        },\r\n\r\n        // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\r\n        complete: function(items) {\r\n            newTmplItems = {};\r\n        },\r\n\r\n        // Call this from code which overrides domManip, or equivalent\r\n        // Manage cloning/storing template items etc.\r\n        afterManip: function afterManip(elem, fragClone, callback) {\r\n            // Provides cloned fragment ready for fixup prior to and after insertion into DOM\r\n            var content = fragClone.nodeType === 11 ?\r\n                    $.makeArray(fragClone.childNodes) :\r\n                    fragClone.nodeType === 1 ? [fragClone] : [];\r\n\r\n            // Return fragment to original caller (e.g. append) for DOM insertion\r\n            callback.call(elem, fragClone);\r\n\r\n            // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by $.data.\r\n            storeTmplItems(content);\r\n            cloneIndex++;\r\n        }\r\n    });\r\n\r\n    //========================== Private helper functions, used by code above ==========================\r\n\r\n    function build(tmplItem, nested, content) {\r\n        // Convert hierarchical content into flat string array\r\n        // and finally return array of fragments ready for DOM insertion\r\n        var frag, ret = content ? $.map(content, function(item) {\r\n            return (typeof item === \"string\") ?\r\n                // Insert template item annotations, to be converted to $.data( \"tmplItem\" ) when elems are inserted into DOM.\r\n                    (tmplItem.key ? item.replace(regex.template_anotate,\r\n                            \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\") : item) :\r\n                // This is a child template item. Build nested template.\r\n                    build(item, tmplItem, item._ctnt);\r\n        }) :\r\n            // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.\r\n                tmplItem;\r\n        if(nested) {\r\n            return ret;\r\n        }\r\n\r\n        // top-level template\r\n        ret = ret.join(\"\");\r\n\r\n        // Support templates which have initial or final text nodes, or consist only of text\r\n        // Also support HTML entities within the HTML markup.\r\n        ret.replace(regex.text_only_template, function(all, before, middle, after) {\r\n            frag = $(middle).get();\r\n\r\n            storeTmplItems(frag);\r\n            if(before) {\r\n                frag = unencode(before).concat(frag);\r\n            }\r\n            if(after) {\r\n                frag = frag.concat(unencode(after));\r\n            }\r\n        });\r\n        return frag ? frag : unencode(ret);\r\n    }\r\n\r\n    function unencode(text) {\r\n        // Use createElement, since createTextNode will not render HTML entities correctly\r\n        var el = document.createElement(\"div\");\r\n        el.innerHTML = text;\r\n        return $.makeArray(el.childNodes);\r\n    }\r\n\r\n    // Generate a reusable function that will serve to render a template against data\r\n    function buildTmplFn(markup) {\r\n        var parse_tag = function(all, slash, type, fnargs, target, parens, args) {\r\n            if(!type) {\r\n                return \"');__.push('\";\r\n            }\r\n\r\n            var tag = $.tmpl.tag[ type ], def, expr, exprAutoFnDetect;\r\n            if(!tag) {\r\n                console.group(\"Exception\");\r\n                console.error(markup);\r\n                console.error('Unknown tag: ', type);\r\n                console.error(all);\r\n                console.groupEnd(\"Exception\");\r\n                return \"');__.push('\";\r\n            }\r\n            def = tag._default || [];\r\n            if(parens && !regex.last_word.test(target)) {\r\n                target += parens;\r\n                parens = \"\";\r\n            }\r\n            if(target) {\r\n                target = unescape(target);\r\n                args = args ? (\",\" + unescape(args) + \")\") : (parens ? \")\" : \"\");\r\n                // Support for target being things like a.toLowerCase();\r\n                // In that case don't call with template item as 'this' pointer. Just evaluate...\r\n                expr = parens ? (target.indexOf(\".\") > -1 ? target + unescape(parens) : (\"(\" + target + \").call($item\" + args)) : target;\r\n                exprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\r\n            } else {\r\n                exprAutoFnDetect = expr = def.$1 || \"null\";\r\n            }\r\n            fnargs = unescape(fnargs);\r\n            return \"');\" +\r\n                   tag[ slash ? \"close\" : \"open\" ]\r\n                           .split(\"$notnull_1\").join(target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\")\r\n                           .split(\"$1a\").join(exprAutoFnDetect)\r\n                           .split(\"$1\").join(expr)\r\n                           .split(\"$2\").join(fnargs || def.$2 || \"\") +\r\n                   \"__.push('\";\r\n        };\r\n\r\n        var depreciated_parse = function() {\r\n            if($.tmpl.tag[arguments[2]]) {\r\n                console.group(\"Depreciated\");\r\n                console.info(markup);\r\n                console.info('Markup has old style indicators, use {% %} instead of {{ }}');\r\n                console.info(arguments[0]);\r\n                console.groupEnd(\"Depreciated\");\r\n                return parse_tag.apply(this, arguments);\r\n            } else {\r\n                return \"');__.push('{{\" + arguments[2] + \"}}');__.push('\";\r\n            }\r\n        };\r\n\r\n        // Use the variable __ to hold a string array while building the compiled template. (See https://github.com/jquery/jquery-tmpl/issues#issue/10).\r\n        // Introduce the data as local variables using with(){}\r\n        var parsed_markup_data = \"var $=$,call,__=[],$data=$item.data; with($data){__.push('\";\r\n\r\n        // Convert the template into pure JavaScript\r\n        var parsed_markup = $.trim(markup);\r\n        parsed_markup = parsed_markup.replace(regex.sq_escape, \"\\\\$1\");\r\n        parsed_markup = parsed_markup.replace(regex.nl_strip, \" \");\r\n        parsed_markup = parsed_markup.replace(regex.shortcut_replace, \"{%= $1%}\");\r\n        parsed_markup = parsed_markup.replace(regex.lang_parse,  parse_tag);\r\n        parsed_markup = parsed_markup.replace(regex.old_lang_parse, depreciated_parse);\r\n        parsed_markup_data += parsed_markup;\r\n\r\n        parsed_markup_data += \"');}return __;\";\r\n\r\n        return new Function(\"$\", \"$item\", parsed_markup_data);\r\n    }\r\n\r\n    function updateWrapped(options, wrapped) {\r\n        // Build the wrapped content.\r\n        options._wrap = build(options, true,\r\n                // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\r\n                $.isArray(wrapped) ? wrapped : [regex.html_expr.test(wrapped) ? wrapped : $(wrapped).html()]\r\n        ).join(\"\");\r\n    }\r\n\r\n    function unescape(args) {\r\n        return args ? args.replace(regex.sq_unescape, \"'\").replace(regex.dq_unescape, \"\\\\\") : null;\r\n    }\r\n\r\n    function outerHtml(elem) {\r\n        var div = document.createElement(\"div\");\r\n        div.appendChild(elem.cloneNode(true));\r\n        return div.innerHTML;\r\n    }\r\n\r\n    // Store template items in $.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\r\n    function storeTmplItems(content) {\r\n        var keySuffix = \"_\" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;\r\n        for(i = 0,l = content.length; i < l; i++) {\r\n            if((elem = content[i]).nodeType !== 1) {\r\n                continue;\r\n            }\r\n            elems = elem.getElementsByTagName(\"*\");\r\n            for(m = elems.length - 1; m >= 0; m--) {\r\n                processItemKey(elems[m]);\r\n            }\r\n            processItemKey(elem);\r\n        }\r\n        function processItemKey(el) {\r\n            var pntKey, pntNode = el, pntItem, tmplItem, key;\r\n            // Ensure that each rendered template inserted into the DOM has its own template item,\r\n            if((key = el.getAttribute(tmplItmAtt))) {\r\n                while(pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute(tmplItmAtt))) {\r\n                }\r\n                if(pntKey !== key) {\r\n                    // The next ancestor with a _tmplitem expando is on a different key than this one.\r\n                    // So this is a top-level element within this template item\r\n                    // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\r\n                    pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute(tmplItmAtt) || 0)) : 0;\r\n                    if(!(tmplItem = newTmplItems[key])) {\r\n                        // The item is for wrapped content, and was copied from the temporary parent wrappedItem.\r\n                        tmplItem = wrappedItems[key];\r\n                        tmplItem = newTmplItem(tmplItem, newTmplItems[pntNode] || wrappedItems[pntNode]);\r\n                        tmplItem.key = ++itemKey;\r\n                        newTmplItems[itemKey] = tmplItem;\r\n                    }\r\n                    if(cloneIndex) {\r\n                        cloneTmplItem(key);\r\n                    }\r\n                }\r\n                el.removeAttribute(tmplItmAtt);\r\n            } else if(cloneIndex && (tmplItem = $.data(el, \"tmplItem\"))) {\r\n                // This was a rendered element, cloned during append or appendTo etc.\r\n                // TmplItem stored in $ data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\r\n                cloneTmplItem(tmplItem.key);\r\n                newTmplItems[tmplItem.key] = tmplItem;\r\n                pntNode = $.data(el.parentNode, \"tmplItem\");\r\n                pntNode = pntNode ? pntNode.key : 0;\r\n            }\r\n            if(tmplItem) {\r\n                pntItem = tmplItem;\r\n                // Find the template item of the parent element.\r\n                // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\r\n                while(pntItem && pntItem.key != pntNode) {\r\n                    // Add this element as a top-level node for this rendered template item, as well as for any\r\n                    // ancestor items between this item and the item of its parent element\r\n                    pntItem.nodes.push(el);\r\n                    pntItem = pntItem.parent;\r\n                }\r\n                // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\r\n                delete tmplItem._ctnt;\r\n                delete tmplItem._wrap;\r\n                // Store template item as $ data on the element\r\n                $.data(el, \"tmplItem\", tmplItem);\r\n            }\r\n            function cloneTmplItem(key) {\r\n                key = key + keySuffix;\r\n                tmplItem = newClonedItems[key] =\r\n                           (newClonedItems[key] || newTmplItem(tmplItem,\r\n                                   newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent));\r\n            }\r\n        }\r\n    }\r\n\r\n    //---- Helper functions for template item ----\r\n\r\n    function tiCalls(content, tmpl, data, options) {\r\n        if(!content) {\r\n            return stack.pop();\r\n        }\r\n        stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });\r\n    }\r\n\r\n    function tiNest(tmpl, data, options) {\r\n        // nested template, using {{tmpl}} tag\r\n        return $.tmpl($.template(tmpl), data, options, this);\r\n    }\r\n\r\n    function tiWrap(call, wrapped) {\r\n        // nested template, using {{wrap}} tag\r\n        var options = call.options || {};\r\n        options.wrapped = wrapped;\r\n        // Apply the template, which may incorporate wrapped content,\r\n        return $.tmpl($.template(call.tmpl), call.data, options, call.item);\r\n    }\r\n\r\n    function tiHtml(filter, textOnly) {\r\n        var wrapped = this._wrap;\r\n        return $.map(\r\n                $($.isArray(wrapped) ? wrapped.join(\"\") : wrapped).filter(filter || \"*\"),\r\n                function(e) {\r\n                    return textOnly ?\r\n                            e.innerText || e.textContent :\r\n                            e.outerHTML || outerHtml(e);\r\n                });\r\n    }\r\n\r\n    function tiUpdate() {\r\n        var coll = this.nodes;\r\n        $.tmpl(null, null, null, this).insertBefore(coll[0]);\r\n        $(coll).remove();\r\n    }\r\n})(jQuery);"]],"start1":0,"start2":0,"length1":0,"length2":25516}]],"length":25516,"saved":false}
